<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Pincal</title>
  
  <subtitle>Pincal&#39;s website</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2019-06-11T14:00:30.000Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>Pincal</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>ES6之let、const详解</title>
    <link href="http://yoursite.com/2019/06/11/let/"/>
    <id>http://yoursite.com/2019/06/11/let/</id>
    <published>2019-06-11T13:34:07.000Z</published>
    <updated>2019-06-11T14:00:30.000Z</updated>
    
    <content type="html"><![CDATA[<p>这篇文章记录下ES6中的let和const。</p><h3 id="一、与var区别"><a href="#一、与var区别" class="headerlink" title="一、与var区别"></a>一、与var区别</h3><p>在ES6之前声明变量使用的是var，变量作用域也只分为全局作用域和函数作用域两种，没有块级作用域的概念。ES6中新增的let和const声明的变量都是块级作用域内的变量，他们跟var声明的变量区别主要是以下几个方面：</p><table><thead><tr><th align="center">声明方式</th><th align="center">作用域</th><th align="center">变量提升</th><th align="center">重复声明</th><th align="center">只声明不赋值</th><th align="center">window的属性</th></tr></thead><tbody><tr><td align="center">var</td><td align="center">函数作用域</td><td align="center">&#10003;</td><td align="center">&#10003;</td><td align="center">&#10003;</td><td align="center">是</td></tr><tr><td align="center">let</td><td align="center">块级作用域</td><td align="center">×</td><td align="center">×</td><td align="center">&#10003;</td><td align="center">不是</td></tr><tr><td align="center">const</td><td align="center">块级作用域</td><td align="center">×</td><td align="center">×</td><td align="center">×</td><td align="center">不是</td></tr></tbody></table><h3 id="二、示例"><a href="#二、示例" class="headerlink" title="二、示例"></a>二、示例</h3><h4 id="1-变量提升"><a href="#1-变量提升" class="headerlink" title="1.变量提升"></a>1.变量提升</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(a);     <span class="comment">// undefined</span></span><br><span class="line"><span class="keyword">var</span> a = <span class="number">1</span>;</span><br><span class="line"><span class="built_in">console</span>.log(a);     <span class="comment">// 1</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(b);     <span class="comment">// 报错</span></span><br><span class="line"><span class="keyword">let</span> b = <span class="number">2</span>;</span><br><span class="line"><span class="built_in">console</span>.log(b);     <span class="comment">// 2</span></span><br></pre></td></tr></table></figure><h4 id="2-重复声明"><a href="#2-重复声明" class="headerlink" title="2.重复声明"></a>2.重复声明</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="number">1</span>;</span><br><span class="line"><span class="built_in">console</span>.log(a);     <span class="comment">// 1</span></span><br><span class="line"><span class="keyword">var</span> a = <span class="number">3</span>;</span><br><span class="line"><span class="built_in">console</span>.log(a);     <span class="comment">// 3</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> b = <span class="number">2</span>;</span><br><span class="line"><span class="built_in">console</span>.log(b);     <span class="comment">// 2</span></span><br><span class="line"><span class="keyword">let</span> b = <span class="number">4</span>;          <span class="comment">// 报错</span></span><br></pre></td></tr></table></figure><h4 id="3-只声明不赋值"><a href="#3-只声明不赋值" class="headerlink" title="3.只声明不赋值"></a>3.只声明不赋值</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a;</span><br><span class="line"><span class="built_in">console</span>.log(a);     <span class="comment">// undefined</span></span><br><span class="line">a = <span class="number">3</span>;</span><br><span class="line"><span class="built_in">console</span>.log(a);     <span class="comment">// 3</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> b;</span><br><span class="line"><span class="built_in">console</span>.log(b);     <span class="comment">// undefined</span></span><br><span class="line">b = <span class="number">4</span>;</span><br><span class="line"><span class="built_in">console</span>.log(b);     <span class="comment">// 4</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> c;            <span class="comment">// 报错</span></span><br></pre></td></tr></table></figure><h4 id="4-顶层对象window的属性"><a href="#4-顶层对象window的属性" class="headerlink" title="4.顶层对象window的属性"></a>4.顶层对象window的属性</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a;</span><br><span class="line"><span class="built_in">console</span>.log(a);     <span class="comment">// undefined</span></span><br><span class="line">a = <span class="number">3</span>;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">window</span>.a);     <span class="comment">// 3</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> b;</span><br><span class="line"><span class="built_in">console</span>.log(b);     <span class="comment">// undefined</span></span><br><span class="line">b = <span class="number">4</span>;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">window</span>.b);     <span class="comment">// undefined</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> c = <span class="number">5</span>;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">window</span>.c);      <span class="comment">// undefined</span></span><br></pre></td></tr></table></figure><p>注意：使用var或者不加任何变量修饰符声明的全局变量都是window对象的属性，使用let和const声明的全局变量都不是window的属性。</p><h4 id="5-与全局变量的关系"><a href="#5-与全局变量的关系" class="headerlink" title="5.与全局变量的关系"></a>5.与全局变量的关系</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 局部变量赋值</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">test</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">let</span> a = <span class="number">1</span>;</span><br><span class="line">    <span class="built_in">console</span>.log(a); <span class="comment">// 1</span></span><br><span class="line">    a = <span class="number">2</span>;</span><br><span class="line">    <span class="built_in">console</span>.log(a); <span class="comment">// 2</span></span><br><span class="line">&#125;</span><br><span class="line">test();</span><br><span class="line"><span class="built_in">console</span>.log(a); <span class="comment">// 报错</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 全局变量</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">test</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">let</span> a = <span class="number">1</span>;</span><br><span class="line">    <span class="built_in">console</span>.log(a); <span class="comment">// 1</span></span><br><span class="line">    b = <span class="number">2</span>;</span><br><span class="line">    <span class="built_in">console</span>.log(b); <span class="comment">// 2</span></span><br><span class="line">&#125;</span><br><span class="line">test();</span><br><span class="line"><span class="built_in">console</span>.log(b); <span class="comment">// 2</span></span><br></pre></td></tr></table></figure><p>注意：如果是在函数作用域或者块级作用域中不加任何变量修饰符声明并给一个变量赋值，那么首先会在该局部作用域中寻找是否有这个变量存在，存在的话会给这个变量赋值，不存在的话就会声明一个全局变量。</p><p>接上面的例子：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">test</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    a = <span class="number">3</span>;          <span class="comment">// 报错</span></span><br><span class="line">    <span class="keyword">let</span> a = <span class="number">1</span>;</span><br><span class="line">    <span class="built_in">console</span>.log(a); <span class="comment">// 1</span></span><br><span class="line">    a = <span class="number">2</span>;</span><br><span class="line">    <span class="built_in">console</span>.log(a); <span class="comment">// 2</span></span><br><span class="line">&#125;</span><br><span class="line">test();</span><br></pre></td></tr></table></figure><p>使用let或者const声明变量以后，这个变量就与它的作用域绑定了，在声明语句之前任何赋值操作都会报错。</p><h3 id="6-一个注意的问题"><a href="#6-一个注意的问题" class="headerlink" title="6. 一个注意的问题"></a>6. 一个注意的问题</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i ++)&#123;</span><br><span class="line">    <span class="keyword">let</span> i;</span><br><span class="line">    <span class="built_in">console</span>.log(i);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这段代码我以为会报错，因为i已经声明过了，在内部相当于重复声明，结果输出了10个undefined，由此可见，for循环语句中的i与要执行的块级作用域中的代码不是同一个作用域。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;这篇文章记录下ES6中的let和const。&lt;/p&gt;
&lt;h3 id=&quot;一、与var区别&quot;&gt;&lt;a href=&quot;#一、与var区别&quot; class=&quot;headerlink&quot; title=&quot;一、与var区别&quot;&gt;&lt;/a&gt;一、与var区别&lt;/h3&gt;&lt;p&gt;在ES6之前声明变量使用的是va
      
    
    </summary>
    
    
      <category term="前端" scheme="http://yoursite.com/tags/%E5%89%8D%E7%AB%AF/"/>
    
      <category term="Javascript" scheme="http://yoursite.com/tags/Javascript/"/>
    
      <category term="ES6" scheme="http://yoursite.com/tags/ES6/"/>
    
  </entry>
  
  <entry>
    <title>跨域之jsonp-使用koa2手动实现一个jsonp</title>
    <link href="http://yoursite.com/2019/06/06/jsonp/"/>
    <id>http://yoursite.com/2019/06/06/jsonp/</id>
    <published>2019-06-06T12:29:00.000Z</published>
    <updated>2019-06-06T12:36:55.000Z</updated>
    
    <content type="html"><![CDATA[<p>跨域是前端面试经常会被问到的一道题目，而跨域其中一种实现方式就是jsonp，这篇博客记录一下jsonp的原理以及使用koa2手动实现jsonp的过程。</p><h2 id="一、跨域的概念"><a href="#一、跨域的概念" class="headerlink" title="一、跨域的概念"></a>一、跨域的概念</h2><p>我们在前端页面中发起XMLHttpRequest请求时，由于浏览器的同源策略会导致跨域。同源是指协议、域名、端口号这三者都要相同，只要其中有任意一个不同，就会导致跨域。浏览器的同源策略主要是防范来自不同源的恶意文件。</p><h2 id="二、jsonp原理"><a href="#二、jsonp原理" class="headerlink" title="二、jsonp原理"></a>二、jsonp原理</h2><p>jsonp解决跨域问题利用的是script标签可以加载任意位置下的文件这个特性，我们把要请求的地址作为script标签的src属性去请求，为了在请求到数据以后前端可以执行对应的回调函数，需要后端在返回的时候做一些相应的支持。</p><h2 id="三、实践"><a href="#三、实践" class="headerlink" title="三、实践"></a>三、实践</h2><p>这部分我们就根据jsonp的原理来手动实现一下。首先是客户端部分的代码，jsonp函数是动态创建script标签并发起请求的过程，handleResponse函数是请求成功以后的回调函数，参数data是请求回来的数据。<br>这里要注意的是jsonp在请求时需要把回调函数的函数名作为参数一起附在请求的url里。</p><h3 id="1、客户端代码"><a href="#1、客户端代码" class="headerlink" title="1、客户端代码"></a>1、客户端代码</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// jsonp</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">jsonp</span>(<span class="params">url</span>)</span>&#123;</span><br><span class="line">    url += <span class="string">'?callback=handleResponse'</span></span><br><span class="line">    <span class="keyword">var</span> scripts = <span class="built_in">document</span>.createElement(<span class="string">"script"</span>);</span><br><span class="line">    scripts.src = url;</span><br><span class="line">    <span class="built_in">document</span>.body.appendChild(scripts);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// callback</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">handleResponse</span>(<span class="params">data</span>)</span>&#123;</span><br><span class="line">    alert(data.age);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 发起jsonp请求</span></span><br><span class="line">jsonp(<span class="string">'http://localhost:3000/users'</span>);</span><br></pre></td></tr></table></figure><h3 id="2、服务端代码"><a href="#2、服务端代码" class="headerlink" title="2、服务端代码"></a>2、服务端代码</h3><p>以上实现了jsonp的客户端代码，服务端代码需要考虑的问题是如何在将数据返回以后可以执行回调函数，首先我们知道客户端在执行回调函数的时候使用的是handleResponse(data)这样的形式，那么我们就需要将后台返回的内容拼接成这样的字符串，那么前端在加载到script标签中的文件时就会执行其中的代码，也就是handleResponse(data)。以下是使用koa2框架实现的服务端代码，这里只附上了实现逻辑部分的代码。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">router.get(<span class="string">'/users'</span>, <span class="function"><span class="keyword">function</span> (<span class="params">ctx, next</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> callback = ctx.query.callback;                             <span class="comment">// 获取回调函数名</span></span><br><span class="line">  <span class="built_in">console</span>.log(callback);</span><br><span class="line">  <span class="keyword">const</span> data = &#123;<span class="string">'name'</span>: <span class="string">'pincal'</span>, <span class="string">'age'</span>: <span class="number">18</span>&#125;;                        <span class="comment">// 构造返回数据</span></span><br><span class="line">  <span class="keyword">const</span> res = callback + <span class="string">'('</span> + <span class="built_in">JSON</span>.stringify(data) + <span class="string">')'</span>;      <span class="comment">// 拼接返回字符串</span></span><br><span class="line">  <span class="built_in">console</span>.log(res);                                                         <span class="comment">// handleResponse(&#123;"name":"pincal","age":18&#125;)</span></span><br><span class="line">  ctx.body = res;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><hr><p>跨域还有一些其他的实现方法，例如CORS，代理等，后面会陆续写完跨域这部分的内容。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;跨域是前端面试经常会被问到的一道题目，而跨域其中一种实现方式就是jsonp，这篇博客记录一下jsonp的原理以及使用koa2手动实现jsonp的过程。&lt;/p&gt;
&lt;h2 id=&quot;一、跨域的概念&quot;&gt;&lt;a href=&quot;#一、跨域的概念&quot; class=&quot;headerlink&quot; ti
      
    
    </summary>
    
    
      <category term="前端" scheme="http://yoursite.com/tags/%E5%89%8D%E7%AB%AF/"/>
    
      <category term="Javascript" scheme="http://yoursite.com/tags/Javascript/"/>
    
      <category term="跨域" scheme="http://yoursite.com/tags/%E8%B7%A8%E5%9F%9F/"/>
    
  </entry>
  
  <entry>
    <title>闭包详解</title>
    <link href="http://yoursite.com/2019/06/04/%E9%97%AD%E5%8C%85/"/>
    <id>http://yoursite.com/2019/06/04/闭包/</id>
    <published>2019-06-04T12:05:29.000Z</published>
    <updated>2019-06-04T15:18:58.000Z</updated>
    
    <content type="html"><![CDATA[<p>这篇文章仔细整理和总结下我对闭包的理解，闭包是经常在面试中会被问到的一个问题，可能因为之前理解不够深刻，经常看了就忘必须要到面试前重新看一遍才能捡起来。</p><h2 id="一、先从一道面试题来看"><a href="#一、先从一道面试题来看" class="headerlink" title="一、先从一道面试题来看"></a>一、先从一道面试题来看</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> test = (<span class="function"><span class="keyword">function</span>(<span class="params">i</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(i * <span class="number">2</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;(<span class="number">2</span>));</span><br><span class="line"><span class="comment">// console.log(test);</span></span><br><span class="line">test();</span><br><span class="line">test(<span class="number">10</span>);</span><br></pre></td></tr></table></figure><p>不用着急看答案，可以先说一下自己的结果，再看看对不对。</p><p>正确的结果应该是：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">test();           <span class="comment">// 结果是4</span></span><br><span class="line">test(<span class="number">10</span>);       <span class="comment">// 结果是4</span></span><br></pre></td></tr></table></figure><p>这里可以尝试输出一下test函数：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ƒ ()&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(i * <span class="number">2</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>那为什么test(10)的执行结果会是4，这里test无论给它传什么参数都会输出4？这就是闭包。</p><h2 id="二、闭包是什么"><a href="#二、闭包是什么" class="headerlink" title="二、闭包是什么"></a>二、闭包是什么</h2><p>那么在上面的题里我们可以把test函数就看作是一个闭包函数，简单点说，闭包就是能够访问其他函数作用域内变量的函数。在上一题里test函数可以访问到定义它的父函数内的变量i,所以它是一个闭包函数。</p><p>大家都知道在JavaScript里面有函数作用域的概念，也就是函数外部无法访问到函数内部的变量，但是函数可以顺着作用域链访问它到外部的变量。</p><p>举一个最简单的例子：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> i = <span class="number">2</span>;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">func</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="keyword">var</span> j = <span class="number">3</span>;</span><br><span class="line">  <span class="built_in">console</span>.log(i);     <span class="comment">// 输出2</span></span><br><span class="line">&#125;</span><br><span class="line">func()</span><br><span class="line"><span class="built_in">console</span>.log(j);       <span class="comment">// 报错</span></span><br></pre></td></tr></table></figure><p>这里的函数func可以访问到位于它外部的变量i，但是函数外部也就是全局执行环境无法访问到函数func的变量j。</p><p>那么想要访问一个函数A内部的变量要怎么做呢？我们可以利用闭包的特性在这个函数A内部定义一个函数B，那么这个函数B就会沿着作用域链访问到函数A的变量，即使函数B被return在全局作用域下执行。</p><p>根据这个原理，我们改造一下上面的代码使之成为一个闭包函数，实现在全局作用域内可以访问到函数func内部的变量j：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">func</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="keyword">var</span> j = <span class="number">3</span>;</span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> <span class="title">in_func</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(j);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">out_func = func();</span><br><span class="line"><span class="built_in">console</span>.log(out_func);</span><br><span class="line">out_func();<span class="comment">// 3</span></span><br></pre></td></tr></table></figure><p>到这里应该就解释清楚了闭包是什么，以及闭包为什么可以访问到其他函数作用域内的变量。</p><h2 id="三、使用场景"><a href="#三、使用场景" class="headerlink" title="三、使用场景"></a>三、使用场景</h2><p>既然知道了闭包是什么，那接下来我们就想知道，为什么要去访问其他函数内部的变量？闭包有哪些具体的使用场景？</p><h3 id="1、封装私有变量"><a href="#1、封装私有变量" class="headerlink" title="1、封装私有变量"></a>1、封装私有变量</h3><p>可以通过闭包来封装私有变量，并且通过一些公用方法来访问和修改私有变量。示例如下：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">test</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> value = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">        <span class="keyword">get</span> : function () &#123;</span><br><span class="line">            <span class="keyword">return</span> value;</span><br><span class="line">        &#125;,</span><br><span class="line">        add : <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">            value += <span class="number">1</span>;</span><br><span class="line">        &#125;,</span><br><span class="line">        reduce : <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">            value -= <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">a = test();</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(a.get());       <span class="comment">// 1</span></span><br><span class="line">a.add()</span><br><span class="line"><span class="built_in">console</span>.log(a.get());       <span class="comment">// 2</span></span><br><span class="line">a.reduce();</span><br><span class="line"><span class="built_in">console</span>.log(a.get());       <span class="comment">// 1</span></span><br></pre></td></tr></table></figure><p>上面的例子里我们通过公有方法get来访问私有变量value的值，通过方法add和reduce来修改私有变量value的值。</p><h3 id="2、为节点循环绑定事件"><a href="#2、为节点循环绑定事件" class="headerlink" title="2、为节点循环绑定事件"></a>2、为节点循环绑定事件</h3><p>示例代码后补。</p><h3 id="3、setTimeOut循环输出"><a href="#3、setTimeOut循环输出" class="headerlink" title="3、setTimeOut循环输出"></a>3、setTimeOut循环输出</h3><p>示例代码后补。</p><h2 id="四、闭包的问题"><a href="#四、闭包的问题" class="headerlink" title="四、闭包的问题"></a>四、闭包的问题</h2><p>前面提到了使用闭包会使函数内部的局部变量一直存在于内存中，增加内存开销，因此滥用闭包可能会降低网页的性能。所以我们要在变量使用结束以后释放它。在前面的例子中：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">func</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">var</span> j = <span class="number">3</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> <span class="title">in_func</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(j);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">out_func = func();</span><br><span class="line"><span class="built_in">console</span>.log(out_func);</span><br><span class="line">out_func();   <span class="comment">// 3</span></span><br><span class="line">  </span><br><span class="line">out_func = <span class="literal">null</span>;          <span class="comment">// 释放对变量的引用</span></span><br></pre></td></tr></table></figure><h2 id="五、跟匿名函数的区别"><a href="#五、跟匿名函数的区别" class="headerlink" title="五、跟匿名函数的区别"></a>五、跟匿名函数的区别</h2><p>因为闭包常常会以匿名函数立即执行的方式实现，因此常常会有人把闭包和匿名函数混淆，其实这两者天差地别。匿名函数只是定义了一个没有函数名的函数，而闭包的特性在于从作用域的角度延长了变量在内存中的生存时间。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;这篇文章仔细整理和总结下我对闭包的理解，闭包是经常在面试中会被问到的一个问题，可能因为之前理解不够深刻，经常看了就忘必须要到面试前重新看一遍才能捡起来。&lt;/p&gt;
&lt;h2 id=&quot;一、先从一道面试题来看&quot;&gt;&lt;a href=&quot;#一、先从一道面试题来看&quot; class=&quot;heade
      
    
    </summary>
    
    
      <category term="前端" scheme="http://yoursite.com/tags/%E5%89%8D%E7%AB%AF/"/>
    
      <category term="Javascript" scheme="http://yoursite.com/tags/Javascript/"/>
    
  </entry>
  
  <entry>
    <title>使用Github Pages和Hexo搭建个人博客（二）- Anatole主题</title>
    <link href="http://yoursite.com/2019/05/18/hexo-2/"/>
    <id>http://yoursite.com/2019/05/18/hexo-2/</id>
    <published>2019-05-18T09:11:19.000Z</published>
    <updated>2019-05-18T10:46:04.000Z</updated>
    
    <content type="html"><![CDATA[<p>上一篇博客介绍了如何使用<a href="https://pages.github.com/" target="_blank" rel="noopener">Github Pages</a> 和 <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a>搭建个人博客，博客搭起来以后我们可以根据自身需求对博客做一些个性化的设置，包括主题更换、加入访问量统计、鼠标点击效果等。</p><h2 id="一、语言设置"><a href="#一、语言设置" class="headerlink" title="一、语言设置"></a>一、语言设置</h2><p>打开站点主目录Blog文件夹中的_config.yml文件，配置如下信息：</p><pre><code>title: Pincalsubtitle: Pincal&apos;s websitedescription: 随便你写什么啦author: Pincallanguage: zh-cntimezone:</code></pre><p>这里可以根据自己情况填写，注意语言这一项有的是zh-cn，有的是zh-Hans，具体需要填写哪个要看你用的主题文件夹中language那个文件夹里的文件名是什么。</p><h2 id="二、主题更换"><a href="#二、主题更换" class="headerlink" title="二、主题更换"></a>二、主题更换</h2><p>这里可以去<a href="https://hexo.io/themes/" target="_blank" rel="noopener">Hexo官网的主题</a>中挑选你喜欢的主题，我这里的主题用的是<a href="https://anatole.munen.cc/" target="_blank" rel="noopener">Anatole</a>，不过遗憾的是这个主题现在已经没有在维护了，如果是新手想要通过简单配置就满足大部分个性化设置推荐使用<a href="https://github.com/theme-next/hexo-theme-next" target="_blank" rel="noopener">next</a>，这个主题用的人很多，配置很全也很方便。</p><h3 id="1-下载主题"><a href="#1-下载主题" class="headerlink" title="1. 下载主题"></a>1. 下载主题</h3><p>找到你的主题的Github页，使用以下命令把主题克隆到你的本地：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">cd</span> blog/themes</span><br><span class="line">$ git <span class="built_in">clone</span> https://github.com/theme-next/hexo-theme-next.git(主题Github地址)</span><br></pre></td></tr></table></figure><h3 id="2-配置文件"><a href="#2-配置文件" class="headerlink" title="2. 配置文件"></a>2. 配置文件</h3><p>打开站点主目录Blog文件夹中的_config.xml文件，theme项配置为你下载的主题名：</p><pre><code>theme: hexo-theme-Anatole</code></pre><h3 id="3-本地查看"><a href="#3-本地查看" class="headerlink" title="3. 本地查看"></a>3. 本地查看</h3><p>配置好以后执行以下3条命令，在本地查看效果：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ hexo clean</span><br><span class="line">$ hexo g</span><br><span class="line">$ hexo s</span><br></pre></td></tr></table></figure><p>由于我用的是Anatole主题，查看时会报错，在blog目录下执行一下下面的命令就好了：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ npm install --save hexo-render-pug</span><br></pre></td></tr></table></figure><h2 id="三、关于页面"><a href="#三、关于页面" class="headerlink" title="三、关于页面"></a>三、关于页面</h2><p>很多主题安装好以后点击关于页面，报错找不到该页面，这时候手动生成一下就好了，在blog目录下执行：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new page <span class="string">"about"</span></span><br></pre></td></tr></table></figure><p>就可以在blog/source文件夹中看到生成了一个about文件夹，里面有一个about.md文件，在里面编辑自己的内容就好啦。友链页面也是同样的操作方法。</p><h2 id="四、配置RSS"><a href="#四、配置RSS" class="headerlink" title="四、配置RSS"></a>四、配置RSS</h2><h3 id="1-安装插件"><a href="#1-安装插件" class="headerlink" title="1. 安装插件"></a>1. 安装插件</h3><p>在blog主目录下安装插件：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ npm install hexo-generator-feed</span><br></pre></td></tr></table></figure><h3 id="2-配置文件-1"><a href="#2-配置文件-1" class="headerlink" title="2. 配置文件"></a>2. 配置文件</h3><h4 id="2-1-在blog主目录的配置文件下添加以下配置"><a href="#2-1-在blog主目录的配置文件下添加以下配置" class="headerlink" title="2.1 在blog主目录的配置文件下添加以下配置:"></a>2.1 在blog主目录的配置文件下添加以下配置:</h4><pre><code>theme: hexo-theme-Anatoleplugins:  hexo-generator-feedfeed:    type: atom    path: atom.xml    limit: 20</code></pre><h4 id="2-2在主题目录下的配置文件中添加以下配置："><a href="#2-2在主题目录下的配置文件中添加以下配置：" class="headerlink" title="2.2在主题目录下的配置文件中添加以下配置："></a>2.2在主题目录下的配置文件中添加以下配置：</h4><pre><code>rss: /atom.xml</code></pre><h2 id="五、添加鼠标点击爱心效果"><a href="#五、添加鼠标点击爱心效果" class="headerlink" title="五、添加鼠标点击爱心效果"></a>五、添加鼠标点击爱心效果</h2><p>将以下js代码添加到主题文件夹-&gt;layout-&gt;partial里的footer.pug中，添加的时候注意pug文件的语法格式：<br><code>!function(e,t,a){function n(){c(&quot;.heart{width: 10px;height: 10px;position: fixed;background: #f00;transform: rotate(45deg);-webkit-transform: rotate(45deg);-moz-transform: rotate(45deg);}.heart:after,.heart:before{content: &#39;&#39;;width: inherit;height: inherit;background: inherit;border-radius: 50%;-webkit-border-radius: 50%;-moz-border-radius: 50%;position: fixed;}.heart:after{top: -5px;}.heart:before{left: -5px;}&quot;),o(),r()}function r(){for(var e=0;e&lt;d.length;e++)d[e].alpha&lt;=0?(t.body.removeChild(d[e].el),d.splice(e,1)):(d[e].y--,d[e].scale+=.004,d[e].alpha-=.013,d[e].el.style.cssText=&quot;left:&quot;+d[e].x+&quot;px;top:&quot;+d[e].y+&quot;px;opacity:&quot;+d[e].alpha+&quot;;transform:scale(&quot;+d[e].scale+&quot;,&quot;+d[e].scale+&quot;) rotate(45deg);background:&quot;+d[e].color+&quot;;z-index:99999&quot;);requestAnimationFrame(r)}function o(){var t=&quot;function&quot;==typeof e.onclick&amp;&amp;e.onclick;e.onclick=function(e){t&amp;&amp;t(),i(e)}}function i(e){var a=t.createElement(&quot;div&quot;);a.className=&quot;heart&quot;,d.push({el:a,x:e.clientX-5,y:e.clientY-5,scale:1,alpha:1,color:s()}),t.body.appendChild(a)}function c(e){var a=t.createElement(&quot;style&quot;);a.type=&quot;text/css&quot;;try{a.appendChild(t.createTextNode(e))}catch(t){a.styleSheet.cssText=e}t.getElementsByTagName(&quot;head&quot;)[0].appendChild(a)}function s(){return&quot;rgb(&quot;+~~(255*Math.random())+&quot;,&quot;+~~(255*Math.random())+&quot;,&quot;+~~(255*Math.random())+&quot;)&quot;}var d=[];e.requestAnimationFrame=function(){return e.requestAnimationFrame||e.webkitRequestAnimationFrame||e.mozRequestAnimationFrame||e.oRequestAnimationFrame||e.msRequestAnimationFrame||function(e){setTimeout(e,1e3/60)}}(),n()}(window,document);</code></p><h2 id="六、添加评论留言功能"><a href="#六、添加评论留言功能" class="headerlink" title="六、添加评论留言功能"></a>六、添加评论留言功能</h2><p>这里用的是valine，注册一个<a href="https://leancloud.cn/" target="_blank" rel="noopener">LeanCloud</a>账号，并创建一个应用，在应用的设置-&gt;应用Key中找到你的App ID和App Key并填入到主题的配置文件中：</p><pre><code>valine:  enable: true  appid: 你的id  appkey: 你的key  notify: false   verify: false  avatar: monsterid  placeholder: &apos;comment&apos;</code></pre><p>这里的avatar是<a href="https://github.com/xCss/Valine/wiki/avatar-setting-for-valine" target="_blank" rel="noopener">评论头像类型设置</a>,可以根据自己喜欢设置，placeholder是评论输入框提示内容。</p><h2 id="六、添加访问量统计功能"><a href="#六、添加访问量统计功能" class="headerlink" title="六、添加访问量统计功能"></a>六、添加访问量统计功能</h2><p>因为我用的这个主题没有这个配置项，只能自己动手丰衣足食了，这里用的是<a href="http://busuanzi.ibruce.info/" target="_blank" rel="noopener">不蒜子</a>。将以下代码嵌入到合适的文件中：</p><pre><code>&lt;script async src=&quot;//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js&quot;&gt;&lt;/script&gt;&lt;span id=&quot;busuanzi_container_site_pv&quot;&gt;本站总访问量&lt;span id=&quot;busuanzi_value_site_pv&quot;&gt;&lt;/span&gt;次&lt;/span&gt;</code></pre><p>这里的js代码可以加载外部js文件，也可以直接把代码保存到本地执行，我这里是直接把上面网址中的js代码复制下来然后嵌入到主题文件夹-&gt;layout-&gt;partial-&gt;footer.pug中的，html标签也是放到footer.pug中，添加的时候注意pug文件的语法格式即可。</p><h2 id="七、Hexo常用命令"><a href="#七、Hexo常用命令" class="headerlink" title="七、Hexo常用命令"></a>七、Hexo常用命令</h2><p>最后总结一下Hexo的一些常用命令：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">hexo clean <span class="comment">#清除缓存</span></span><br><span class="line">hexo g  <span class="comment">#生成文件</span></span><br><span class="line">hexo s  <span class="comment">#启动本地服务</span></span><br><span class="line">hexo d  <span class="comment">#发布到远程</span></span><br><span class="line">hexo new page <span class="string">"你的页面名称"</span> <span class="comment">#生成页面</span></span><br><span class="line">hexo new <span class="string">"你的文章名"</span> <span class="comment">#生成文章</span></span><br></pre></td></tr></table></figure><hr><p>到这里基本就可以满足的我的大部分配置需求了，还有一些其它的配置：头像更改、社交网站链接之类的比较简单我就不放在这里了，后续的话还打算买个域名基本就差不多了。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;上一篇博客介绍了如何使用&lt;a href=&quot;https://pages.github.com/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Github Pages&lt;/a&gt; 和 &lt;a href=&quot;https://hexo.io/&quot; target=&quot;_bla
      
    
    </summary>
    
      <category term="hexo" scheme="http://yoursite.com/categories/hexo/"/>
    
      <category term="other" scheme="http://yoursite.com/categories/hexo/other/"/>
    
    
  </entry>
  
  <entry>
    <title>使用Github Pages和Hexo搭建个人博客（一）</title>
    <link href="http://yoursite.com/2019/05/18/hexo_1/"/>
    <id>http://yoursite.com/2019/05/18/hexo_1/</id>
    <published>2019-05-18T08:11:19.000Z</published>
    <updated>2019-05-18T09:13:32.000Z</updated>
    
    <content type="html"><![CDATA[<p>这两天利用零碎时间搭了个人博客，第一篇博客就介绍下使用<a href="https://pages.github.com/" target="_blank" rel="noopener">Github Pages</a> 和 <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a>搭建个人博客的过程，我这里的环境是Mac。</p><h2 id="一、本地工作"><a href="#一、本地工作" class="headerlink" title="一、本地工作"></a>一、本地工作</h2><h3 id="1-环境准备"><a href="#1-环境准备" class="headerlink" title="1. 环境准备"></a>1. 环境准备</h3><ul><li>安装<a href="https://nodejs.org/en/" target="_blank" rel="noopener">node.js</a></li><li>安装<a href="https://git-scm.com/downloads" target="_blank" rel="noopener">git</a></li></ul><h3 id="2-安装hexo"><a href="#2-安装hexo" class="headerlink" title="2. 安装hexo"></a>2. 安装hexo</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sudo npm install -g hexo</span><br></pre></td></tr></table></figure><h3 id="3-初始化"><a href="#3-初始化" class="headerlink" title="3. 初始化"></a>3. 初始化</h3><p>创建一个文件夹命名为blog，进入该文件夹，执行初始化命令</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">cd</span> blog</span><br><span class="line">$ hexo init</span><br></pre></td></tr></table></figure><h3 id="4-启动本地服务器"><a href="#4-启动本地服务器" class="headerlink" title="4. 启动本地服务器"></a>4. 启动本地服务器</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">cd</span> blog</span><br><span class="line">$ npm install</span><br><span class="line">$ hexo s</span><br></pre></td></tr></table></figure><p>这时候在浏览器输入 <a href="http://localhost:4000" target="_blank" rel="noopener">http://localhost:4000</a> 就可以看到个人博客的首页了。</p><h2 id="二、Github配置"><a href="#二、Github配置" class="headerlink" title="二、Github配置"></a>二、Github配置</h2><p>以上第一步完成以后我们可以在本地看到自己的博客了，想要把这个博客发布出去让其他人也看到，我们就需要使用Github Pages。</p><h3 id="1-创建仓库"><a href="#1-创建仓库" class="headerlink" title="1. 创建仓库"></a>1. 创建仓库</h3><p>在你的Github账户中新建一个仓库，Repository name为：pincal(你的Github用户名).github.io，这样以后你的博客就可以通过这个地址来访问了。</p><h3 id="2-本地配置Github账号和邮箱"><a href="#2-本地配置Github账号和邮箱" class="headerlink" title="2. 本地配置Github账号和邮箱"></a>2. 本地配置Github账号和邮箱</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ git config --global user.name <span class="string">"pincal"</span>// Github用户名</span><br><span class="line">$ git config --global user.email  <span class="string">"xxx@qq.com"</span>// Github邮箱</span><br></pre></td></tr></table></figure><h3 id="3-配置ssh-key"><a href="#3-配置ssh-key" class="headerlink" title="3. 配置ssh key"></a>3. 配置ssh key</h3><h4 id="3-1-生成ssh-key"><a href="#3-1-生成ssh-key" class="headerlink" title="3.1 生成ssh key"></a>3.1 生成ssh key</h4><p>在本地命令行中输入以下命令生成key：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ ssh-keygen -t rsa -C <span class="string">"Github邮件地址"</span></span><br></pre></td></tr></table></figure><p>这里的参数-C的意思是comment to identify the key，也就是用于识别这个密钥的注释，理论上你输入任何内容都是可以的，很多网站使用邮箱作为识别这个key的注释。<br>执行完这个命令以后会在你本地生成2个文件，其中一个文件保存公钥，另一个文件保存私钥。</p><h4 id="3-2-key配置到Github"><a href="#3-2-key配置到Github" class="headerlink" title="3.2 key配置到Github"></a>3.2 key配置到Github</h4><p>在你的Github的个人设置 -&gt; SSH and GPG keys -&gt; New SSH key中，填入你上面生成的id_rsa.pub文件中的内容。然后在本地输入以下命令测试是否配置成功：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ ssh -T git@github.com</span><br></pre></td></tr></table></figure><p>You’ve successfully authenticated, but GitHub does not provide shell access.看到这个信息就代表你配置成功了。</p><h3 id="4-发布到Github"><a href="#4-发布到Github" class="headerlink" title="4. 发布到Github"></a>4. 发布到Github</h3><h4 id="4-1-配置文件"><a href="#4-1-配置文件" class="headerlink" title="4.1 配置文件"></a>4.1 配置文件</h4><p>打开blog文件夹中的_config.yml,在deploy的配置项中添加以下配置：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">deploy:</span><br><span class="line">  type: git</span><br><span class="line">  repo: https://github.com/你的Github用户名/你的Github用户名.github.io.git</span><br><span class="line">  branch: master</span><br></pre></td></tr></table></figure><h4 id="4-2-发布"><a href="#4-2-发布" class="headerlink" title="4.2 发布"></a>4.2 发布</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ npm install hexo-deployer-git --save</span><br><span class="line">$ hexo d</span><br></pre></td></tr></table></figure><p>过程中要输入Github用户名和密码，这时候在浏览器输入你前面配置好的Github仓库名就可以看到你的博客了。</p><hr><p>到这里我们就完成最初级的个人博客搭建了，下一篇介绍一下关于博客的个人化配置。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;这两天利用零碎时间搭了个人博客，第一篇博客就介绍下使用&lt;a href=&quot;https://pages.github.com/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Github Pages&lt;/a&gt; 和 &lt;a href=&quot;https://hexo.io
      
    
    </summary>
    
      <category term="hexo" scheme="http://yoursite.com/categories/hexo/"/>
    
      <category term="other" scheme="http://yoursite.com/categories/hexo/other/"/>
    
    
  </entry>
  
</feed>
